#!/usr/bin/env python
################################################################################
# FEAT3: Finite Element Analysis Toolbox, Version 3
# Copyright (C) 2010 - 2021 by Stefan Turek & the FEAT group
# FEAT3 is released under the GNU General Public License version 3,
# see the file 'copyright.txt' in the top level directory for details.
################################################################################
# SuperLU_DIST 7.1.1 patch for Visual Studio
# ------------------------------------------------------------------------------
# This script generates the required Zoltan config header file and patches
# a handful of Zoltan header files to ensure that the library can be compiled
# under Visual Studio 16 or higher.
#
# \author Peter Zajac
################################################################################
import os
import sys

def write_config(filename):
  # make sure that the config does not exist yet
  if os.path.isfile(filename):
    print("Config Header '%s' alrady exists" % filename)
    return
  print("Writing Config Header '%s'..." % filename)
  fo = open(filename, "wt")
  fo.write("/* Zoltan config header generated by FEAT3 'vc_patch_zoltan.py' */\n")
  fo.write("#define HAVE_MPI 1\n")
  fo.write("#define UNSIGNED_LONG_LONG_GLOBAL_IDS 1\n")
  fo.write("#define strcasecmp _stricmp\n")
  fo.write("#define strncasecmp _strnicmp\n")
  fo.close()

# patch_lst entry: [line-no, original, patched]
def patch_file(filename, patch_lst):
  print("Patching '%s'..." % filename)
  # create backup file if it doesn't exist
  filename_b = filename + ".backup"
  if not os.path.isfile(filename_b):
    os.rename(filename, filename_b)
  # open backup file for reading
  fi = open(filename_b, "rt")
  # open file for writing
  fo = open(filename, "wt")
  # loop over all input file lines
  lno = 0
  for line in fi:
    lno = lno + 1
    if (len(patch_lst) > 0) and (patch_lst[0][0] == lno):
      # this line is to be patched
      if line.strip() != patch_lst[0][1]:
        print("ERROR: when processing file '%s': in line %i" % (filename, lno))
        print("expected : '%s'" % patch_lst[0][1])
        print("but found: '%s'" % line.strip())
        print("Patch aborted!")
        sys.exit(1)
      # okay replace line
      fo.write(patch_lst[0][2] + "\n")
      # remove patch line
      patch_lst = patch_lst[1:]
    else:
      fo.write(line)
  # ensure that all patches were applied
  if len(patch_lst) > 0:
    print("ERROR: when processing file '%s': end of file found, but there are still patches left")
    print("Patch aborted!")
    sys.exit(1)
  # okay, that's it
  fo.close()
  fi.close()

########################################################################################################################
########################################################################################################################
########################################################################################################################

# set Zoltan source directory
src_dir = os.path.join(".", "Zoltan", "src")

# make sure that Zoltan exists here
if not os.path.isfile(os.path.join(src_dir, "include", "zoltan.h")):
  print("ERROR: Zoltan source not found; nothing to patch...")
  sys.exit(1)

# write config file
write_config(os.path.join(src_dir, "include", "Zoltan_config.h"))

# patch "zz/zz_const.c"
patch_file(os.path.join(src_dir, "zz", "zz_const.h"), [
  [55, "#include <strings.h>", "/*#include <strings.h>*/"]
])

# patch "zz/zz_util.c"
patch_file(os.path.join(src_dir, "zz", "zz_util.c"), [
  [55, "#include <unistd.h>", "/*#include <unistd.h>*/"]
])

# patch "rcb/inertial2d.c"
patch_file(os.path.join(src_dir, "rcb", "inertial2d.c"), [
  [66, "#define max(a, b) ((a) < (b) ? (b) : (a))", "/*#define max(a, b) ((a) < (b) ? (b) : (a))*/"],
  [67, "#define min(a, b) ((a) > (b) ? (b) : (a))", "/*#define min(a, b) ((a) > (b) ? (b) : (a))*/"]
])

# patch "rcb/inertial3d.c"
patch_file(os.path.join(src_dir, "rcb", "inertial3d.c"), [
  [54, "#define max(a, b) ((a) < (b) ? (b) : (a))", "/*#define max(a, b) ((a) < (b) ? (b) : (a))*/"],
  [55, "#define min(a, b) ((a) > (b) ? (b) : (a))", "/*#define min(a, b) ((a) > (b) ? (b) : (a))*/"]
])

# patch "phg/phg_util.c"
patch_file(os.path.join(src_dir, "phg", "phg_util.c"), [
  [75, "{", "{/*"],
  [85, "}", "*/}"]
])

# okay
print("Patch applied successfully")
